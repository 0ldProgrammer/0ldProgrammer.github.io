---
title: "Exploitation d'une vulnérabilité de type ROP"
description: test.png
tags: ["Dans cet article je vous présente comment exploiter une vulnérabilité de type ROP (Return-oriented programming) permet de contourner des mécanismes notammement l'ASLR et le système NX."]
---

![forthebadge made-with-python](https://media.giphy.com/media/xT9IgG50Fb7Mi0prBC/giphy.gif)

Comment t'allez-vous ? Après un long moment d'absence je décide de revenir pour vous proposez un article sur le `pwn`, plus précisement sur l'exploitation d'une vulnérabilité de type `ROP` (Return-oriented programming).

Vous êtes intéressé ? Alors LET'S GO !

Prérequis :
- Avoir les bases en `pwn` de comprendre et comment attaquer un buffer overflow basique.
- Et d'un ordinateur, eh eh !

# Explication du système ROP

Avant de commencer l'exploitation, il faut bien comprendre à quoi sert ce système et de comprendre son fonctionnement.

Le `ROP`, return-oriented programming, est une technique d'exploitation avancée de type dépassement de pile (stack overflow) permettant l'exécution de code par un attaquant et ce en s'affranchissant plus ou moins efficacement des mécanismes de protection tels que l'utilisation de zones mémoires non-exécutables (cf. bit NX pour Data Execution Prevention, DEP), l'utilisation d'un espace d'adressage aléatoire (Address Space Layout Randomization, `ASLR`).

Notre but concrètement c'est de récupérer des instructions du binaire pour ensuite faire un rassemblement d'instruction (les bouts d'instruction on appel ça un `gadget` c'est le langage utilisé quand nous exploitons du ROP). Imagions que nous avons des instructions basique. (C'est un exemple bien evidamment)

    push   ebp                # Instruction 1
    mov    ebp,esp            # Instruction 2
    push   ecx                # Instruction 3
    sub    esp,0x4            # Instruction 4
    call   0x804848b <secret> # Instruction 5 
    mov    eax,0x0            # Instruction 6

Imaginons que par la suite, nous décidons de prendre les instructions qui nous intéresse pour ensuite faire un rassemblement d'instruction, par exemple.

    push   ebp                # Instruction 1
    mov    ebp,esp            # Instruction 2
    mov    eax,0x0            # Instruction 6

Justement, notre but c'est de récupérer les instructions du binaire pour ensuite modifier le comportement du programme et d'exécuter quelques choses qui nous intéresse par exemple un `SHELL`, eh oui !

Alors, rassurez-vous je vais vous faire une petite démonstration, donc pas de panique.

# Le programme et la compilation

Donc avant tout ça, nous allons activer l'`ASLR` (pour grosso modo randomisée la pile, le tas et également la libc) à l'aide d'une commande.

    root@0xEX75:~/rop# echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

Et voici le programme en C que nous allons exploiter par la suite.

    #include <stdio.h>
    #include <stdlib.h>

    void function_vulnerability()
    {
            char buffer[8];
            gets(buffer);
            printf("%s\n", buffer);
    }

    int main(int argc, char **argv)
    {
            function_vulnerability();
            return 0;
    }

La commande pour la compilation du programme (je vais quand même vous expliquez les options), alors concrètement l'option `-m32` permet de compiler le programme avec 32 bits comme son nom l'indique.

`-static` Cette option permet grosso modo d’intégrer les bibliothèques dynamiques à notre binaire pour avoir un fichier beaucoup plus lourd. Pourquoi ? Si nous avons un fichier beaucoup plus lourd, nous aurons beaucoup plus d'instruction à mettre. Eh oui !

Et finalement l'option `-fno-stack-protector` permet de désactiver le Canari (nous aurons besoin de le désactiver pour effectuer notre attaque par buffer overflow, mais c'est très possible de bypass cette "sécurité").

    root@0xEX75:~/rop# gcc -m32 -static -fno-stack-protector vuln.c -o rop

Parfait, notre programme est prêt à être exploiter.

# Exploitation du programme

Les choses commence à être intéréssant, nous allons essayer de trouver le `padding` pour écraser le `Return Address Overwrite` ou bien `l'adresse de retour` (ou sauvegarde `EIP`).

Nous allons créer un petit pattern pour trouver le padding à l'aide d'un outil que vous pouvez installer rapidement [ici](https://github.com/Svenito/exploit-pattern) et par la suite lancer la commande juste ci-dessous.

    root@0xEX75:~/rop# pattern create 100
    Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Et lançons `gdb` (GNU Debugger), et ensuite d'envoyer les octets au programme pour trouver le bon `padding`. Il y a bien evidamment d'autre technique pour trouver le `padding` mais c'est la technique la plus amusante selon moi et plus simple aha.

    root@0xEX75:~/rop# gdb -q rop
    Reading symbols from rop...(no debugging symbols found)...done.
    gdb-peda$ r <<< Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
    Program received signal SIGSEGV, Segmentation fault.                                                                                                                            
    [----------------------------------registers-----------------------------------]                                                                                                
    EAX: 0x65 ('e')
    EBX: 0x80481a8 (<_init>:        push   ebx)
    ECX: 0xffffffff 
    EDX: 0x80ec4d4 --> 0x0 
    ESI: 0x80eb00c --> 0x80642f0 (<__strcpy_ssse3>: mov    edx,DWORD PTR [esp+0x4])
    EDI: 0x0 
    EBP: 0x61413561 ('a5Aa')
    ESP: 0xffffd540 ("Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    EIP: 0x37614136 ('6Aa7')
    EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
    Invalid $PC address: 0x37614136
    [------------------------------------stack-------------------------------------]
    0000| 0xffffd540 ("Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0004| 0xffffd544 ("a9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0008| 0xffffd548 ("0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0012| 0xffffd54c ("Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0016| 0xffffd550 ("b3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0020| 0xffffd554 ("4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0024| 0xffffd558 ("Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0028| 0xffffd55c ("b7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Stopped reason: SIGSEGV
    0x37614136 in ?? ()
    gdb-peda$

Par la suite, nous allons à nouveau utiliser le programme pour trouver pour de bon le `padding`, donc d'après le programme nous aurons besoin de `24` octets pour écraser la sauvegarde `EIP` donc l'adresse de retour. 

    root@0xEX75:~/rop# pattern offset 0x37614136 100
    20

Comme au début de l'article notre but est de pop un shell même si l'`ASLR` est open et également le système `NX`, pour ça nous devons trouver une fonction qui permet d'exécuter une commande par exemple. 

Voici une bonne liste de fonction que nous pouvons appliquer pour l'exploitation de notre programme [ICI](https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html).
